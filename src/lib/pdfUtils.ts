import jsPDF from 'jspdf';

export type PdfLang = 'fr' | 'en' | 'ar';

export type BrandingInfo = {
  logoDataUrl?: string;
  address?: string;
  phone?: string;
  email?: string;
  location?: string;
  timeZone?: string;
};

const BRAND = {
  color: '#6366F1', // indigo-500
  textDark: '#111827',
  textMuted: '#6B7280',
  border: '#E5E7EB',
};

const PAGE = {
  width: 210, // A4 mm
  height: 297,
  marginX: 14,
  marginTop: 16,
  marginBottom: 16,
};

export function svgElementToPngDataUrl(svgEl: SVGElement, outWidthPx = 900, outHeightPx = 300): Promise<string> {
  return new Promise<string>((resolve, reject) => {
    try {
      const xml = new XMLSerializer().serializeToString(svgEl);
      const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
      const image64 = 'data:image/svg+xml;base64,' + svg64;
      const img = new Image();
      img.onload = () => {
        try {
          const canvas = document.createElement('canvas');
          canvas.width = outWidthPx;
          canvas.height = outHeightPx;
          const ctx = canvas.getContext('2d');
          if (!ctx) return reject(new Error('No 2D context'));
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
          const iw = img.width * scale;
          const ih = img.height * scale;
          const ix = (canvas.width - iw) / 2;
          const iy = (canvas.height - ih) / 2;
          ctx.drawImage(img, ix, iy, iw, ih);
          resolve(canvas.toDataURL('image/png'));
        } catch (e) { reject(e as any); }
      };
      img.onerror = () => reject(new Error('Failed to load SVG data URL'));
      img.src = image64;
    } catch (e) { reject(e as any); }
  });
}

export function beginDoc(title: string, centerName: string, lang: PdfLang = 'fr', branding?: BrandingInfo) {
  const doc = new jsPDF();
  // Register fonts (if cached) to support Arabic only when needed
  registerFontsSyncFromLocalStorage(doc, lang);
  // Header band
  doc.setDrawColor(BRAND.color);
  doc.setFillColor(BRAND.color);
  doc.rect(0, 0, PAGE.width, 16, 'F');

  // Header text
  doc.setTextColor('#FFFFFF');
  setLangFont(doc, lang, 'bold');
  doc.setFontSize(12);
  const headerTitle = centerName || (lang === 'fr' ? 'Établissement' : lang === 'ar' ? 'المؤسسة' : 'Center');
  doc.text(headerTitle, PAGE.marginX, 10);

  // Optional logo at top-right inside header band
  if (branding?.logoDataUrl) {
    try {
      // 14mm right margin, logo approx 12mm high maintaining band height
      const logoW = 20; const logoH = 12;
      doc.addImage(branding.logoDataUrl, 'PNG', PAGE.width - PAGE.marginX - logoW, 2, logoW, logoH);
    } catch {}
  }

  doc.setTextColor(BRAND.textDark);
  setLangFont(doc, lang, 'bold');
  doc.setFontSize(16);
  doc.text(title, PAGE.marginX, 30);

  // Contact block (top-right under band)
  const contactLines: string[] = [];
  if (branding?.address) contactLines.push(branding.address);
  if (branding?.location) contactLines.push(branding.location);
  const phoneEmail = [branding?.phone, branding?.email].filter(Boolean).join(' • ');
  if (phoneEmail) contactLines.push(phoneEmail);
  if (branding?.timeZone) contactLines.push(`TZ: ${branding.timeZone}`);
  if (contactLines.length) {
    doc.setFont('helvetica', '');
    doc.setTextColor(BRAND.textMuted);
    doc.setFontSize(9.5);
    const rightX = PAGE.width - PAGE.marginX;
    let cy = 22;
    contactLines.forEach((ln) => { doc.text(String(ln), rightX, cy, { align: 'right' }); cy += 4.2; });
  }

  const y = 36;
  return { doc, y };
}

export function footer(doc: jsPDF, lang: PdfLang, author?: string) {
  const metaY = PAGE.height - PAGE.marginBottom;
  doc.setDrawColor(BRAND.border);
  doc.setLineWidth(0.2);
  doc.line(PAGE.marginX, metaY - 6, PAGE.width - PAGE.marginX, metaY - 6);

  doc.setTextColor(BRAND.textMuted);
  doc.setFont('helvetica', '');
  doc.setFontSize(9);
  const genBy = lang === 'fr' ? 'Généré par EduManage' : lang === 'ar' ? 'تم الإنشاء بواسطة EduManage' : 'Generated by EduManage';
  const locale = lang === 'fr' ? 'fr-FR' : lang === 'ar' ? 'ar-MA' : 'en-US';
  const dateStr = new Intl.DateTimeFormat(locale, { dateStyle: 'medium', timeStyle: 'short', timeZone: 'Africa/Casablanca' }).format(new Date());
  const meta = `${genBy} • ${dateStr}${author ? ` • ${author}` : ''}`;
  doc.text(meta, PAGE.marginX, metaY);
  // Localized confidentiality note (center)
  const conf = lang === 'fr' ? 'Confidentiel — Usage interne uniquement' : lang === 'ar' ? 'سري — للاستخدام الداخلي فقط' : 'Confidential — Internal use only';
  doc.text(conf, PAGE.width / 2, metaY, { align: 'center' });
}

export function applyFooters(doc: jsPDF, lang: PdfLang, author?: string) {
  const pageCount = (doc as any).getNumberOfPages ? (doc as any).getNumberOfPages() : ((doc as any).internal?.getNumberOfPages?.() || 1);
  const pageLabel = lang === 'fr' ? 'Page' : lang === 'ar' ? 'الصفحة' : 'Page';
  for (let i = 1; i <= pageCount; i++) {
    (doc as any).setPage(i);
    footer(doc, lang, author);
    const metaY = PAGE.height - PAGE.marginBottom;
    doc.setTextColor(BRAND.textMuted);
    doc.setFont('helvetica', '');
    doc.setFontSize(9);
    doc.text(`${pageLabel} ${i} / ${pageCount}`, PAGE.width - PAGE.marginX, metaY, { align: 'right' });
  }
}

export function setPdfMetadata(doc: jsPDF, meta: { title?: string; author?: string; subject?: string; keywords?: string }) {
  try {
    (doc as any).setProperties?.({
      title: meta.title || '',
      subject: meta.subject || '',
      author: meta.author || 'EduManage',
      keywords: meta.keywords || 'EduManage, Report',
    });
  } catch {}
}

export function addSubtitle(doc: jsPDF, text: string, y: number) {
  doc.setTextColor(BRAND.textMuted);
  doc.setFont('helvetica', '');
  doc.setFontSize(11);
  doc.text(text, PAGE.marginX, y);
  return y + 6;
}

export function drawTable(
  doc: jsPDF,
  columns: string[],
  rows: string[][],
  startY: number,
  opts?: { lang?: PdfLang; maxWidthMm?: number; align?: Array<'left'|'right'|'center'>; colWidthsMm?: number[] }
) {
  const padX = 2.5; // mm
  const lineH = 4.2; // mm
  const maxWidth = Math.min(opts?.maxWidthMm || (PAGE.width - PAGE.marginX * 2), PAGE.width - PAGE.marginX * 2);

  // Heuristic: measure header + sample rows to set proportional widths
  const measure = (s: string) => {
    doc.setFontSize(10);
    return Math.max(10, doc.getTextWidth(String(s || '')) + padX * 2);
  };
  const weights = columns.map((c, i) => {
    let w = measure(c);
    for (let r = 0; r < Math.min(rows.length, 30); r++) {
      w = Math.max(w, measure(String(rows[r]?.[i] ?? '')));
    }
    return w;
  });
  const total = weights.reduce((a, b) => a + b, 0) || 1;
  const colW = (opts?.colWidthsMm && opts.colWidthsMm.length === columns.length)
    ? opts.colWidthsMm
    : weights.map(w => Math.max(18, (w / total) * maxWidth)); // min width per col

  // Normalize to fit exactly maxWidth
  const sumW = colW.reduce((a, b) => a + b, 0);
  const scale = maxWidth / sumW;
  const widths = colW.map(w => w * scale);

  // Alignment per column (default: auto-detect numeric -> right)
  const autoAlign = (idx: number): 'left'|'right'|'center' => {
    let numeric = 0, considered = 0;
    for (let r = 0; r < Math.min(rows.length, 50); r++) {
      const v = String(rows[r]?.[idx] ?? '').trim();
      if (!v) continue; considered++;
      if (/^[-+]?(\d+[\s,]?)*(\.?\d+)?(\s*(MB|MAD|DH|%))?$/.test(v)) numeric++;
    }
    return numeric > Math.max(2, considered * 0.6) ? 'right' : 'left';
  };
  const aligns = columns.map((_, i) => opts?.align?.[i] || autoAlign(i));

  // Draw header
  let y = startY;
  doc.setFillColor('#EEF2FF');
  doc.setDrawColor(BRAND.border);
  doc.setTextColor(BRAND.textDark);
  setLangFont(doc, opts?.lang || 'fr', 'bold');
  doc.setFontSize(10.5);
  let x = PAGE.marginX;
  for (let i = 0; i < columns.length; i++) {
    const w = widths[i];
    doc.rect(x, y - 5, w, 8, 'F');
    doc.text(columns[i], x + padX, y + 1, { align: 'left' });
    x += w;
  }
  y += 9; // header row height

  // Body
  setLangFont(doc, opts?.lang || 'fr', 'normal');
  doc.setFontSize(10);
  for (let r = 0; r < rows.length; r++) {
    // Compute row height by splitting each cell text
    const splitPerCol: string[][] = [];
    let rowH = lineH; // minimum
    for (let i = 0; i < columns.length; i++) {
      const txt = String(rows[r]?.[i] ?? '');
      const split = doc.splitTextToSize(txt, Math.max(2, widths[i] - padX * 2));
      splitPerCol.push(split);
      rowH = Math.max(rowH, split.length * lineH);
    }

    // Page break if needed (leave some bottom space for footer)
    if (y + rowH > PAGE.height - 20) {
      doc.addPage();
      y = PAGE.marginTop;
      // Redraw header on new page
      x = PAGE.marginX;
      doc.setFillColor('#EEF2FF'); doc.setDrawColor(BRAND.border); doc.setTextColor(BRAND.textDark);
      setLangFont(doc, opts?.lang || 'fr', 'bold'); doc.setFontSize(10.5);
      for (let i = 0; i < columns.length; i++) {
        const w = widths[i];
        doc.rect(x, y - 5, w, 8, 'F');
        doc.text(columns[i], x + padX, y + 1, { align: 'left' });
        x += w;
      }
      y += 9;
      setLangFont(doc, opts?.lang || 'fr', 'normal'); doc.setFontSize(10); doc.setTextColor(0);
    }

    // Draw row cells
    x = PAGE.marginX;
    for (let i = 0; i < columns.length; i++) {
      const w = widths[i];
      doc.setDrawColor(BRAND.border);
      doc.rect(x, y - 4, w, rowH + 2);
      const lines = splitPerCol[i];
      for (let li = 0; li < lines.length; li++) {
        const textY = y + li * lineH;
        if (aligns[i] === 'right') {
          doc.text(lines[li], x + w - padX, textY, { align: 'right' });
        } else if (aligns[i] === 'center') {
          doc.text(lines[li], x + w / 2, textY, { align: 'center' });
        } else {
          doc.text(lines[li], x + padX, textY, { align: 'left' });
        }
      }
      x += w;
    }
    y += rowH + 3;
  }
  return y;
}

export async function exportTimetablePdf(opts: {
  lang: PdfLang;
  centerName: string;
  groupName: string;
  byDay: Record<number, Array<{ startTime: string; endTime: string; title?: string; subject?: string; teacher?: string; classroom?: string }>>;
}) {
  console.log(' NEW PROFESSIONAL TIMETABLE PDF GENERATOR CALLED!');
  console.log(' Options:', opts);
  
  const { lang, centerName, groupName, byDay } = opts;

  // Create professional landscape document
  const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
  
  // Load fonts for better typography
  const containsArabic = Object.values(byDay).some(list =>
    (list || []).some(s => /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF]/.test(String(s.title || s.subject || '')))
  );
  await preloadPdfFonts(containsArabic ? 'ar' : lang);
  registerFontsSyncFromLocalStorage(doc, containsArabic ? 'ar' : lang);
  await ensureCanvasFonts();

  // Professional color scheme (using RGB values for jsPDF)
  const colors = {
    primary: [37, 99, 235],      // Blue-600
    secondary: [100, 116, 139],  // Slate-500
    accent: [241, 245, 249],     // Slate-100
    border: [203, 213, 225],     // Slate-300
    text: [30, 41, 59],          // Slate-800
    textLight: [100, 116, 139],  // Slate-500
    white: [255, 255, 255]
  };

  // Page dimensions
  const pageWidth = doc.internal.pageSize.getWidth(); // 297mm
  const pageHeight = doc.internal.pageSize.getHeight(); // 210mm
  const margin = 15;
  const contentWidth = pageWidth - (margin * 2);

  console.log(' Page dimensions:', { pageWidth, pageHeight, margin, contentWidth });

  // Helper functions
  const clean = (txt: string) => String(txt ?? '').replace(/\s+/g, ' ').trim();
  const toMin = (s: string) => { 
    const [h, m] = (s || '00:00').split(':').map(x => parseInt(x, 10) || 0); 
    return h * 60 + m; 
  };
  const toTimeStr = (m: number) => `${String(Math.floor(m / 60)).padStart(2, '0')}:${String(m % 60).padStart(2, '0')}`;

  // Professional header with institution branding
  let currentY = margin;
  
  console.log(' Drawing professional header...');
  
  // Header background
  doc.setFillColor(...colors.primary);
  doc.rect(0, 0, pageWidth, 25, 'F');
  
  // Institution name
  doc.setTextColor(...colors.white);
  setLangFont(doc, lang, 'bold');
  doc.setFontSize(14);
  doc.text(centerName || 'EduManage', margin, 12);
  
  // Export date
  const now = new Date();
  const dateStr = now.toLocaleDateString('fr-FR', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  doc.setFontSize(10);
  doc.text(`Export: ${dateStr}`, pageWidth - margin, 12, { align: 'right' });
  
  currentY = 35;

  // Main title with elegant styling
  console.log(' Drawing elegant title...');
  
  doc.setTextColor(...colors.text);
  setLangFont(doc, lang, 'bold');
  doc.setFontSize(24);
  const title = clean(groupName || (lang === 'fr' ? 'Emploi du Temps' : 'Timetable'));
  doc.text(title, pageWidth / 2, currentY, { align: 'center' });
  
  // Subtitle line
  doc.setLineWidth(0.5);
  doc.setDrawColor(...colors.primary);
  const titleWidth = doc.getTextWidth(title);
  const lineStart = (pageWidth - titleWidth) / 2;
  const lineEnd = lineStart + titleWidth;
  doc.line(lineStart, currentY + 3, lineEnd, currentY + 3);
  
  currentY += 20;

  // Time slots configuration (8:00 to 22:00)
  const timeSlots = [];
  for (let hour = 8; hour <= 21; hour++) {
    timeSlots.push({
      label: String(timeSlots.length + 1),
      start: hour * 60,
      end: (hour + 1) * 60,
      timeRange: `${String(hour).padStart(2, '0')}-${String(hour + 1).padStart(2, '0')}`
    });
  }

  console.log(' Time slots configured:', timeSlots.length);

  // Days configuration
  const dayOrder = [1, 2, 3, 4, 5, 6, 0]; // Monday to Sunday
  const dayLabels = {
    fr: ['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa'],
    en: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    ar: ['الأحد', 'الإثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت']
  };
  const getDayLabel = (dayIndex: number) => dayLabels[lang as keyof typeof dayLabels][dayIndex];

  // Grid dimensions
  const dayColumnWidth = 25;
  const timeColumnWidth = (contentWidth - dayColumnWidth) / timeSlots.length;
  const rowHeight = 20;
  const headerHeight = 25;

  console.log(' Grid dimensions:', { dayColumnWidth, timeColumnWidth, rowHeight, headerHeight });

  // Draw header row with time slots
  let gridY = currentY;
  
  console.log(' Drawing professional grid...');
  
  // Empty corner cell
  doc.setFillColor(...colors.accent);
  doc.setDrawColor(...colors.border);
  doc.setLineWidth(0.3);
  doc.rect(margin, gridY, dayColumnWidth, headerHeight, 'FD');
  
  // Time slot headers
  timeSlots.forEach((slot, index) => {
    const x = margin + dayColumnWidth + (index * timeColumnWidth);
    
    // Header cell background
    doc.setFillColor(...colors.accent);
    doc.rect(x, gridY, timeColumnWidth, headerHeight, 'FD');
    
    // Slot number
    doc.setTextColor(...colors.text);
    setLangFont(doc, lang, 'bold');
    doc.setFontSize(11);
    doc.text(slot.label, x + timeColumnWidth/2, gridY + 8, { align: 'center' });
    
    // Time range
    doc.setTextColor(...colors.textLight);
    setLangFont(doc, lang, 'normal');
    doc.setFontSize(8);
    doc.text(slot.timeRange, x + timeColumnWidth/2, gridY + 18, { align: 'center' });
  });
  
  gridY += headerHeight;

  // Draw day rows
  dayOrder.forEach((dayIndex) => {
    const rowY = gridY;
    
    // Day label cell
    doc.setFillColor(...colors.accent);
    doc.setDrawColor(...colors.border);
    doc.rect(margin, rowY, dayColumnWidth, rowHeight, 'FD');
    
    doc.setTextColor(...colors.text);
    setLangFont(doc, lang, 'bold');
    doc.setFontSize(14);
    doc.text(getDayLabel(dayIndex), margin + dayColumnWidth/2, rowY + rowHeight/2 + 2, { align: 'center' });
    
    // Time slot cells for this day
    timeSlots.forEach((slot, slotIndex) => {
      const cellX = margin + dayColumnWidth + (slotIndex * timeColumnWidth);
      
      // Empty cell
      doc.setFillColor(...colors.white);
      doc.setDrawColor(...colors.border);
      doc.rect(cellX, rowY, timeColumnWidth, rowHeight, 'FD');
    });
    
    // Add sessions for this day
    const daySessions = byDay[dayIndex] || [];
    console.log(` Day ${getDayLabel(dayIndex)} sessions:`, daySessions.length);
    
    daySessions.forEach((session) => {
      const startMin = toMin(session.startTime);
      const endMin = toMin(session.endTime);
      
      // Find which slots this session spans
      let startSlot = -1;
      let endSlot = -1;
      
      timeSlots.forEach((slot, index) => {
        if (startMin >= slot.start && startMin < slot.end) startSlot = index;
        if (endMin > slot.start && endMin <= slot.end) endSlot = index;
      });
      
      if (startSlot >= 0 && endSlot >= 0) {
        const spanSlots = endSlot - startSlot + 1;
        const sessionX = margin + dayColumnWidth + (startSlot * timeColumnWidth);
        const sessionWidth = spanSlots * timeColumnWidth;
        
        // Session background with gradient effect
        doc.setFillColor(224, 242, 254); // Light blue
        doc.setDrawColor(...colors.primary);
        doc.setLineWidth(0.5);
        doc.rect(sessionX + 1, rowY + 1, sessionWidth - 2, rowHeight - 2, 'FD');
        
        // Session content
        const subject = clean(session.title || session.subject || '');
        const teacher = clean(session.teacher || '');
        const classroom = clean(session.classroom || '');
        
        // Subject name (main text)
        if (subject) {
          doc.setTextColor(...colors.text);
          setLangFont(doc, lang, 'bold');
          doc.setFontSize(9);
          
          // Fit text to cell width
          let fontSize = 9;
          doc.setFontSize(fontSize);
          while (doc.getTextWidth(subject) > sessionWidth - 6 && fontSize > 6) {
            fontSize -= 0.5;
            doc.setFontSize(fontSize);
          }
          
          doc.text(subject, sessionX + sessionWidth/2, rowY + 7, { 
            align: 'center',
            maxWidth: sessionWidth - 4
          });
        }
        
        // Teacher name (smaller, below subject)
        if (teacher) {
          doc.setTextColor(...colors.textLight);
          setLangFont(doc, lang, 'normal');
          doc.setFontSize(7);
          doc.text(`Prof. ${teacher}`, sessionX + 2, rowY + rowHeight - 6);
        }
        
        // Classroom (right side, small)
        if (classroom) {
          doc.setTextColor(...colors.textLight);
          setLangFont(doc, lang, 'normal');
          doc.setFontSize(7);
          doc.text(classroom, sessionX + sessionWidth - 2, rowY + rowHeight - 6, { align: 'right' });
        }
      }
    });
    
    gridY += rowHeight;
  });

  // Professional footer
  const footerY = pageHeight - 15;
  
  console.log(' Adding professional footer...');
  
  // Footer line
  doc.setDrawColor(...colors.border);
  doc.setLineWidth(0.3);
  doc.line(margin, footerY - 5, pageWidth - margin, footerY - 5);
  
  // Footer text
  doc.setTextColor(...colors.textLight);
  setLangFont(doc, lang, 'normal');
  doc.setFontSize(8);
  
  const footerLeft = lang === 'fr' 
    ? 'Généré par EduManage - Système de Gestion Éducative'
    : lang === 'ar'
    ? 'تم الإنشاء بواسطة EduManage - نظام الإدارة التعليمية'
    : 'Generated by EduManage - Educational Management System';
  
  doc.text(footerLeft, margin, footerY);
  
  const footerRight = `${dateStr} - ${now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' })}`;
  doc.text(footerRight, pageWidth - margin, footerY, { align: 'right' });



  // Save with professional filename
  const filename = `emploi_du_temps_${clean(groupName).replace(/\s+/g, '_')}_${now.toISOString().split('T')[0]}.pdf`;
  
  console.log(' Saving professional timetable PDF:', filename);
  console.log(' NEW PROFESSIONAL TIMETABLE GENERATED SUCCESSFULLY!');
  
  doc.save(filename);
}

export async function exportReportPdf(opts: {
  lang: PdfLang;
  centerName: string;
  title: string;
  author?: string;
  subtitle?: string;
  tables?: Array<{ title?: string; columns: string[]; rows: string[][] }>;
  charts?: Array<{ el: Element | null; title?: string; heightPx?: number; summary?: string }>;
  branding?: BrandingInfo;
  filters?: Array<{ label: string; value: string }>;
  notes?: string[];
}) {
  const { lang, centerName, title, author, subtitle, tables = [], charts = [], branding, filters = [], notes = [] } = opts;
  // Preload fonts only for Arabic
  await preloadPdfFonts(lang);
  const hdr = beginDoc(title, centerName, lang, branding);
  const doc = hdr.doc;
  // Register again in this doc (safe no-op if not available)
  registerFontsSyncFromLocalStorage(doc, lang);
  // Default content font based on language
  setLangFont(doc, lang, 'normal');
  let y = hdr.y;

  // Metadata
  setPdfMetadata(doc, { title, author, subject: 'Report', keywords: `${centerName}, ${title}` });

  if (subtitle) y = addSubtitle(doc, subtitle, y);
  const genOnLabel = lang === 'fr' ? 'Date de génération' : lang === 'ar' ? 'تاريخ الإنشاء' : 'Generated on';
  const locale = lang === 'fr' ? 'fr-FR' : lang === 'ar' ? 'ar-MA' : 'en-US';
  const genStr = new Intl.DateTimeFormat(locale, { dateStyle: 'medium', timeStyle: 'short', timeZone: 'Africa/Casablanca' }).format(new Date());
  y = addSubtitle(doc, `${genOnLabel}: ${genStr}`, y);
  y += 2;

  // Optional notes (e.g., Amounts in MAD)
  if (notes && notes.length) {
    doc.setTextColor(BRAND.textMuted);
    doc.setFont('helvetica','italic');
    doc.setFontSize(9.5);
    for (const note of notes) {
      doc.text(String(note), PAGE.marginX, y);
      y += 4;
    }
    y += 2;
  }

  // Optional filters used (as a small table)
  if (filters && filters.length) {
    const titleLabel = lang === 'fr' ? 'Filtres utilisés' : lang === 'ar' ? 'الفلاتر المستخدمة' : 'Filters Used';
    doc.setTextColor(BRAND.textDark);
    doc.setFont('helvetica','bold');
    doc.setFontSize(12);
    doc.text(titleLabel, PAGE.marginX, y);
    y += 6;
    const rows = filters.map(f => [String(f.label || ''), String(f.value || '')]);
    y = drawTable(doc, [lang==='fr'?'Filtre':'Filter', lang==='ar'?'القيمة':'Value'], rows, y + 4, { lang, maxWidthMm: PAGE.width - PAGE.marginX * 2 });
    y += 4;
  }

  for (const t of tables) {
    if (t.title) {
      doc.setTextColor(BRAND.textDark);
      doc.setFont('helvetica','bold');
      doc.setFontSize(12);
      doc.text(t.title, PAGE.marginX, y);
      y += 6;
    }
    y = drawTable(doc, t.columns, t.rows, y + 4, { lang, maxWidthMm: PAGE.width - PAGE.marginX * 2 });
    y += 4;
  }

  for (const c of charts) {
    const container = c.el as HTMLElement | null;
    if (!container) continue;
    const svg = container.querySelector('svg');
    if (!svg) continue;
    try {
      const png = await svgElementToPngDataUrl(svg as any, 900, c.heightPx || 260);
      const imgW = PAGE.width - PAGE.marginX * 2;
      const imgH = 70; // mm
      const imgY = y;
      doc.addImage(png, 'PNG', PAGE.marginX, imgY, imgW, imgH);
      if (c.title) {
        doc.setTextColor(BRAND.textMuted);
        doc.setFont('helvetica','');
        doc.setFontSize(10);
        doc.text(c.title, PAGE.marginX, imgY - 2);
      }
      // Optional textual summary for accessibility/print clarity
      if (c.summary) {
        doc.setTextColor(BRAND.textMuted);
        doc.setFont('helvetica','italic');
        doc.setFontSize(9);
        doc.text(c.summary, PAGE.marginX, imgY + imgH + 6);
        y = imgY + imgH + 12;
      } else {
        y = imgY + imgH + 8;
      }
      if (y > PAGE.height - 40) { doc.addPage(); y = PAGE.marginTop; }
    } catch {}
  }

  // Apply footer to all pages with page numbers
  applyFooters(doc, lang, author);
  doc.save(`${title.replace(/\s+/g,'_').toLowerCase()}_${new Date().toISOString().split('T')[0]}.pdf`);
}

/**
 * Draw a circular stamp with the center's name.
 * - Draws two concentric circles
 * - Center name across the stamp at a slight angle
 * - Small label at top and date at bottom
 */
export function drawCircularStamp(
  doc: jsPDF,
  centerName: string,
  x: number,
  y: number,
  radius = 24,
  lang: PdfLang = 'fr',
  opts?: { phone?: string; email?: string; address?: string }
) {
  const brand = { r: 37, g: 99, b: 235 }; // tailwind blue-600
  // Circles
  doc.setDrawColor(brand.r, brand.g, brand.b);
  doc.setLineWidth(1.4);
  doc.circle(x, y, radius, 'S');
  doc.setLineWidth(0.9);
  doc.circle(x, y, radius - 4, 'S');

  // Arc text helper: draw characters along an arc, centered, upright.
  // If orient === 'bottom', we reverse character order so letters remain upright and readable.
  const drawArcTextCentered = (text: string, r: number, centerDeg: number, sweepDeg: number, orient: 'top' | 'bottom' = 'top') => {
    const arcLen = 2 * Math.PI * r * (sweepDeg / 360);
    // Auto font size based on arc length
    let size = 11;
    doc.setFont('helvetica', 'italic');
    doc.setTextColor(brand.r, brand.g, brand.b);
    doc.setFontSize(size);
    while (doc.getTextWidth(text) > Math.max(1, arcLen - 6) && size > 7) {
      size -= 0.5;
      doc.setFontSize(size);
    }
    const charsRaw = (text || '').split('');
    const chars = orient === 'bottom' ? charsRaw.reverse() : charsRaw;
    const widths = chars.map(ch => Math.max(0.1, doc.getTextWidth(ch)));
    const totalW = widths.reduce((a,b)=>a+b,0);
    const startDeg = centerDeg - sweepDeg / 2;
    const degPerUnit = sweepDeg / Math.max(1e-3, totalW);
    let acc = 0;
    for (let i=0;i<chars.length;i++) {
      const ch = chars[i];
      const half = widths[i] / 2;
      const angleDeg = startDeg + (acc + half) * degPerUnit;
      const rad = angleDeg * Math.PI / 180;
      const tx = x + r * Math.cos(rad);
      const ty = y + r * Math.sin(rad);
      // Upright orientation: tangent angle at theta is angle + 90 (clockwise baseline in jsPDF)
      const rot = angleDeg + 90;
      doc.text(ch, tx, ty, { angle: rot, align: 'center' });
      acc += widths[i];
    }
  };
  // Top arc: center name (centered at 270° to draw on the TOP in PDF coords)
  const nameText = (centerName || 'ÉTABLISSEMENT').toUpperCase();
  drawArcTextCentered(nameText, radius - 3.4, 270, 155, 'top');
  // Bottom arc text removed per request: keep only the school name on the top arc

  // Center block: contact + date, wrapped and vertically centered inside
  doc.setFont('helvetica', 'normal');
  const innerR = radius - 6;
  const maxW = Math.max(16, innerR * 2 - 4);
  doc.setFontSize(7.6);
  doc.setTextColor(70);
  const address = (opts?.address || '').toString();
  const addressShort = address.length > 90 ? address.slice(0, 88) + '…' : address;
  const lines: string[] = [];
  if (opts?.phone) lines.push(String(opts.phone));
  if (opts?.email) lines.push(String(opts.email));
  if (addressShort) {
    const addrLines = doc.splitTextToSize(addressShort, maxW);
    addrLines.forEach((ln: string) => lines.push(ln));
  }
  const dateStr = new Date().toLocaleDateString(lang === 'fr' ? 'fr-FR' : lang === 'ar' ? 'ar-MA' : 'en-US');
  lines.push(dateStr);
  // Compute vertical centering inside inner ring area
  const lineGap = 2.6;
  const blockH = Math.max(lineGap, lines.length * lineGap);
  const startY = y - blockH / 2 + Math.max(1.4, radius * 0.04); // slight downward shift
  lines.forEach((ln, idx) => {
    // Make last line (date) slightly lighter and smaller
    if (idx === lines.length - 1) { doc.setFontSize(7); doc.setTextColor(95); }
    else { doc.setFontSize(7.6); doc.setTextColor(70); }
    doc.text(ln, x, startY + idx * lineGap, { align: 'center', maxWidth: maxW });
  });
}

/**
 * Convenience helper to place the stamp at bottom-right of the page.
 */
export function placeStampBottomRight(doc: jsPDF, centerName: string, lang: PdfLang = 'fr', padding = 22, radius = 24, opts?: { phone?: string; email?: string; address?: string }) {
  const x = doc.internal.pageSize.getWidth() - padding - radius;
  const y = doc.internal.pageSize.getHeight() - padding - radius;
  drawCircularStamp(doc, centerName, x, y, radius, lang, opts);
}

/**
 * Convenience helper to place the stamp at top-right of the page.
 */
export function placeStampTopRight(doc: jsPDF, centerName: string, lang: PdfLang = 'fr', padding = 22, radius = 24, opts?: { phone?: string; email?: string; address?: string }) {
  const x = doc.internal.pageSize.getWidth() - padding - radius;
  const y = padding + radius;
  drawCircularStamp(doc, centerName, x, y, radius, lang, opts);
}

// Canvas helpers for high-quality, mixed-language text rendering
const PX_PER_MM = 96 / 25.4; // browser CSS pixels per mm at 96 DPI

function makeTitleLines(title: string): { ar: string; lat: string } {
  const t = String(title || '').trim();
  // Pattern: Arabic part then optional (Latin)
  const m = t.match(/^(.+?)\s*(\((.+?)\))?$/);
  let ar = (m?.[1] || t).trim();
  let lat = (m?.[3] ? `(${m[3]})` : '').trim();
  return { ar, lat };
}

function drawTwoLineTitleToPng(title: string, maxWidthMm: number, opts?: { color?: string; maxFontPx?: number; minFontPx?: number; gapPx?: number }) {
  const color = opts?.color || '#141414';
  const maxFontPx = opts?.maxFontPx ?? 21;
  const minFontPx = opts?.minFontPx ?? 10;
  const gapPx = opts?.gapPx ?? 6;
  const padPx = 6; // left/right padding inside the image
  const { ar, lat } = makeTitleLines(title);
  const widthPx = Math.max(40, Math.floor(maxWidthMm * PX_PER_MM));
  // Try to pick a font size that fits both lines within widthPx - 2*padPx
  const fontFamilyAr = 'Noto Naskh Arabic, Noto Sans Arabic, Segoe UI, Arial, sans-serif';
  const fontFamilyLat = 'Helvetica, Arial, sans-serif';
  const tryMeasure = (px: number) => {
    const c = document.createElement('canvas');
    const ctx = c.getContext('2d')!;
    ctx.font = `${px}px ${fontFamilyAr}`;
    const arW = ar ? ctx.measureText(ar).width : 0;
    ctx.font = `${px}px ${fontFamilyLat}`;
    const latW = lat ? ctx.measureText(lat).width : 0;
    return Math.max(arW, latW);
  };
  let f = maxFontPx;
  while (f > minFontPx && tryMeasure(f) > (widthPx - padPx * 2)) f -= 1;
  const line1Px = f; // Arabic
  const line2Px = Math.max(minFontPx, Math.round(f * 0.9)); // Latin slightly smaller
  // Build final canvas height with some breathing room
  const heightPx = (ar ? line1Px : 0) + (ar && lat ? gapPx : 0) + (lat ? line2Px : 0) + 4;
  const canvas = document.createElement('canvas');
  canvas.width = widthPx; canvas.height = Math.max(18, Math.ceil(heightPx));
  const ctx = canvas.getContext('2d')!;
  ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic'; ctx.fillStyle = color;
  let cy = 0;
  if (ar) {
    ctx.font = `${line1Px}px ${fontFamilyAr}`;
    // direction rtl for better kerning, center-align still used for centering box
    // @ts-ignore
    ctx.direction = 'rtl';
    cy = Math.ceil(line1Px + 1);
    ctx.fillText(ar, widthPx / 2, cy);
  }
  if (lat) {
    // @ts-ignore
    ctx.direction = 'ltr';
    ctx.font = `${line2Px}px ${fontFamilyLat}`;
    const y2 = Math.ceil((ar ? cy + gapPx + line2Px : line2Px) + 1);
    ctx.fillText(lat, widthPx / 2, y2);
  }
  return { dataUrl: canvas.toDataURL('image/png'), widthMm: maxWidthMm, heightMm: canvas.height / PX_PER_MM };
}

// Font helpers: load TTF from public/fonts into localStorage and register with jsPDF
let fontsPreloaded = false;
async function preloadPdfFonts(lang?: PdfLang) {
  // Only preload fonts when needed (Arabic)
  if (lang !== 'ar') return;
  if (fontsPreloaded) return;
  const toBase64 = async (url: string) => {
    try {
      const res = await fetch(url);
      if (!res.ok) return null;
      const buf = await res.arrayBuffer();
      // Convert ArrayBuffer to base64
      let binary = '';
      const bytes = new Uint8Array(buf);
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize) as any);
      }
      return btoa(binary);
    } catch { return null; }
  };
  try {
    if (!localStorage.getItem('pdfFont_NotoNaskhArabic_Regular')) {
      const b64 = await toBase64('/fonts/NotoNaskhArabic-Regular.ttf');
      if (b64 && b64.length > 1024) localStorage.setItem('pdfFont_NotoNaskhArabic_Regular', b64);
    }
    // Also try NotoSansArabic as an alternative that has clean Latin glyphs
    if (!localStorage.getItem('pdfFont_NotoSansArabic_Regular')) {
      const b64b = await toBase64('/fonts/NotoSansArabic-Regular.ttf');
      if (b64b && b64b.length > 1024) localStorage.setItem('pdfFont_NotoSansArabic_Regular', b64b);
    }
  } catch {}
  fontsPreloaded = true;
}

function tryAddFontFromLS(doc: jsPDF, key: string, fileName: string, fontName: string) {
  try {
    const data = localStorage.getItem(key);
    if (!data || data.length < 1024) return false;
    (doc as any).addFileToVFS?.(fileName, data);
    (doc as any).addFont?.(fileName, fontName, 'normal');
    return true;
  } catch {
    // Corrupted cache; remove
    try { localStorage.removeItem(key); } catch {}
    return false;
  }
}

function registerFontsSyncFromLocalStorage(doc: jsPDF, lang?: PdfLang) {
  try {
    // Only register Arabic font when needed
    if (lang === 'ar') {
      tryAddFontFromLS(doc, 'pdfFont_NotoNaskhArabic_Regular', 'NotoNaskhArabic-Regular.ttf', 'NotoNaskhArabic');
      tryAddFontFromLS(doc, 'pdfFont_NotoSansArabic_Regular', 'NotoSansArabic-Regular.ttf', 'NotoSansArabic');
    }
  } catch {}
}

function setLangFont(doc: jsPDF, lang: PdfLang, weight: 'bold'|'normal' = 'normal') {
  try {
    if (lang === 'ar') {
      const list = (doc as any).getFontList?.() || {};
      if (list['NotoNaskhArabic']) { doc.setFont('NotoNaskhArabic', 'normal'); return; }
      if (list['NotoSansArabic']) { doc.setFont('NotoSansArabic', 'normal'); return; }
      // Fallback to core font if Arabic font unavailable
      doc.setFont('helvetica', weight);
      return;
    }
    doc.setFont('helvetica', weight);
  } catch { doc.setFont('helvetica', weight); }
}

// Ensure canvas can use Arabic+Latin fonts (same-origin served from /fonts)
async function ensureCanvasFonts() {
  try {
    // If fonts already available, skip
    // @ts-ignore
    const hasNaskh = Array.from((document as any).fonts || []).some((f: FontFace) => String(f.family).includes('Noto Naskh Arabic'));
    // @ts-ignore
    const hasSansAr = Array.from((document as any).fonts || []).some((f: FontFace) => String(f.family).includes('Noto Sans Arabic'));
    const toLoad: FontFace[] = [];
    if (!hasNaskh) {
      toLoad.push(new FontFace('Noto Naskh Arabic', "url('/fonts/NotoNaskhArabic-Regular.ttf') format('truetype')", { style: 'normal', weight: '400' }));
    }
    if (!hasSansAr) {
      toLoad.push(new FontFace('Noto Sans Arabic', "url('/fonts/NotoSansArabic-Regular.ttf') format('truetype')", { style: 'normal', weight: '400' }));
    }
    if (toLoad.length) {
      const loaded = await Promise.allSettled(toLoad.map(f => f.load()));
      loaded.forEach((res) => {
        if (res.status === 'fulfilled') {
          try { (document as any).fonts?.add(res.value); } catch {}
        }
      });
    }
  } catch { /* ignore */ }
}
